"""
Claude Agent SDK backend for PocketPaw.

Uses the official Claude Agent SDK (pip install claude-agent-sdk) which provides:
- Built-in tools: Bash, Read, Write, Edit, Glob, Grep, WebSearch, WebFetch
- Streaming responses
- PreToolUse hooks for security
- Permission management
- MCP server support for custom tools
"""

import logging
from collections.abc import AsyncIterator
from pathlib import Path
from typing import Any

from pocketpaw.agents.backend import BackendInfo, Capability
from pocketpaw.agents.protocol import AgentEvent
from pocketpaw.config import Settings
from pocketpaw.security.rails import DANGEROUS_SUBSTRINGS as DANGEROUS_PATTERNS
from pocketpaw.tools.policy import ToolPolicy

logger = logging.getLogger(__name__)

# Default identity fallback (used when AgentContextBuilder prompt is not available)
_DEFAULT_IDENTITY = (
    "You are PocketPaw, a helpful AI assistant running locally on the user's computer."
)


class ClaudeSDKBackend:
    """Claude Agent SDK backend â€” the recommended default.

    Provides all built-in tools (Bash, Read, Write, Edit, Glob, Grep,
    WebSearch, WebFetch), streaming responses, PreToolUse hooks for
    security, and MCP server support.

    Requires: pip install claude-agent-sdk
    """

    _TOOL_POLICY_MAP: dict[str, str] = {
        "Bash": "shell",
        "Read": "read_file",
        "Write": "write_file",
        "Edit": "edit_file",
        "Glob": "list_dir",
        "Grep": "shell",
        "WebSearch": "browser",
        "WebFetch": "browser",
        "Skill": "skill",
    }

    @staticmethod
    def info() -> BackendInfo:
        return BackendInfo(
            name="claude_agent_sdk",
            display_name="Claude Agent SDK",
            capabilities=(
                Capability.STREAMING
                | Capability.TOOLS
                | Capability.MCP
                | Capability.MULTI_TURN
                | Capability.CUSTOM_SYSTEM_PROMPT
            ),
            builtin_tools=[
                "Bash",
                "Read",
                "Write",
                "Edit",
                "Glob",
                "Grep",
                "WebSearch",
                "WebFetch",
            ],
            tool_policy_map=ClaudeSDKBackend._TOOL_POLICY_MAP,
            required_keys=["anthropic_api_key"],
            supported_providers=["anthropic", "ollama", "openai_compatible"],
        )

    def __init__(self, settings: Settings):
        self.settings = settings
        self._stop_flag = False
        self._sdk_available = False
        self._cli_available = False  # Whether the `claude` CLI binary is installed
        self._cwd = settings.file_jail_path  # Default working directory
        self._policy = ToolPolicy(
            profile=settings.tool_profile,
            allow=settings.tools_allow,
            deny=settings.tools_deny,
        )

        # Persistent client â€” reuses subprocess across messages.
        # _client_in_use prevents concurrent queries on the same client
        # (cross-session messages fall back to stateless query()).
        self._client = None
        self._client_options_key: str | None = None
        self._client_in_use = False

        # SDK imports (set during initialization)
        self._query = None
        self._ClaudeSDKClient = None
        self._ClaudeAgentOptions = None
        self._HookMatcher = None
        self._AssistantMessage = None
        self._UserMessage = None
        self._SystemMessage = None
        self._ResultMessage = None
        self._TextBlock = None
        self._ToolUseBlock = None
        self._ToolResultBlock = None
        self._StreamEvent = None

        self._initialize()

    def _initialize(self) -> None:
        """Initialize the Claude Agent SDK with all imports."""
        try:
            # Core SDK imports
            # Message type imports
            # Content block imports
            from claude_agent_sdk import (
                AssistantMessage,
                ClaudeAgentOptions,
                ClaudeSDKClient,
                HookMatcher,
                ResultMessage,
                SystemMessage,
                TextBlock,
                ToolResultBlock,
                ToolUseBlock,
                UserMessage,
                query,
            )

            # Store references
            self._query = query
            self._ClaudeSDKClient = ClaudeSDKClient
            self._ClaudeAgentOptions = ClaudeAgentOptions
            self._HookMatcher = HookMatcher
            self._AssistantMessage = AssistantMessage
            self._UserMessage = UserMessage
            self._SystemMessage = SystemMessage
            self._ResultMessage = ResultMessage
            self._TextBlock = TextBlock
            self._ToolUseBlock = ToolUseBlock
            self._ToolResultBlock = ToolResultBlock

            # StreamEvent for token-by-token streaming (optional)
            try:
                from claude_agent_sdk import StreamEvent

                self._StreamEvent = StreamEvent
            except ImportError:
                self._StreamEvent = None
                logger.info("StreamEvent not available - coarse-grained streaming only")

            self._sdk_available = True

            # Check if the `claude` CLI binary is actually installed
            import shutil

            if shutil.which("claude"):
                self._cli_available = True
                logger.info("âœ“ Claude Agent SDK ready â”€ cwd: %s", self._cwd)
            else:
                logger.warning(
                    "âš ï¸ Claude Code CLI not found on PATH. "
                    "Install with: npm install -g @anthropic-ai/claude-code"
                )

        except ImportError as e:
            logger.warning("âš ï¸ Claude Agent SDK not installed â”€ pip install claude-agent-sdk")
            logger.debug("Import error: %s", e)
            self._sdk_available = False
        except Exception as e:
            logger.error(f"âŒ Failed to initialize Claude Agent SDK: {e}")
            self._sdk_available = False

    def set_working_directory(self, path: Path) -> None:
        """Set the working directory for file operations."""
        self._cwd = path
        logger.info(f"ðŸ“‚ Working directory set to: {path}")

    def _is_dangerous_command(self, command: str) -> str | None:
        """Check if a command matches dangerous patterns.

        Args:
            command: Command string to check

        Returns:
            The matched pattern if dangerous, None otherwise
        """
        command_lower = command.lower()
        for pattern in DANGEROUS_PATTERNS:
            if pattern.lower() in command_lower:
                return pattern
        return None

    async def _block_dangerous_hook(self, input_data, tool_use_id: str | None, context) -> dict:
        """PreToolUse hook to block dangerous commands.

        This hook is called before any Bash command is executed.
        Returns a deny decision for dangerous commands.

        The callback must be resilient â€” an unhandled exception here
        tears down the entire CLI stream.

        Args:
            input_data: PreToolUseHookInput (TypedDict with tool_name,
                tool_input, tool_use_id, etc.)
            tool_use_id: Match group or None
            context: HookContext from the SDK

        Returns:
            Empty dict to allow, or deny decision dict to block
        """
        try:
            tool_name = input_data.get("tool_name", "")
            tool_input = input_data.get("tool_input", {})

            # Only check Bash commands
            if tool_name != "Bash":
                return {}

            command = str(tool_input.get("command", ""))

            matched = self._is_dangerous_command(command)
            if matched:
                logger.warning(f"ðŸ›‘ BLOCKED dangerous command: {command[:100]}")
                logger.warning(f"   â””â”€ Matched pattern: {matched}")
                return {
                    "hookSpecificOutput": {
                        "hookEventName": "PreToolUse",
                        "permissionDecision": "deny",
                        "permissionDecisionReason": (
                            f"PocketPaw security: '{matched}' pattern is blocked"
                        ),
                    }
                }

            logger.debug(f"âœ… Allowed command: {command[:50]}...")
            return {}
        except Exception as e:
            logger.error(f"Hook callback error (allowing command): {e}")
            return {}

    def _extract_text_from_message(self, message: Any) -> str:
        """Extract text content from an AssistantMessage.

        Args:
            message: AssistantMessage with content blocks

        Returns:
            Concatenated text from all TextBlocks
        """
        if not hasattr(message, "content"):
            return ""

        content = message.content
        if content is None:
            return ""

        if isinstance(content, str):
            return content

        if isinstance(content, list):
            texts = []
            for block in content:
                # Check if it's a TextBlock
                if self._TextBlock and isinstance(block, self._TextBlock):
                    if hasattr(block, "text") and block.text:
                        texts.append(block.text)
                # Fallback: check for text attribute
                elif hasattr(block, "text") and isinstance(block.text, str):
                    texts.append(block.text)
            return "".join(texts)

        return ""

    def _extract_tool_info(self, message: Any) -> list[dict]:
        """Extract tool use information from an AssistantMessage.

        Args:
            message: AssistantMessage with content blocks

        Returns:
            List of tool use dicts with name and input
        """
        if not hasattr(message, "content") or message.content is None:
            return []

        tools = []
        for block in message.content:
            if self._ToolUseBlock and isinstance(block, self._ToolUseBlock):
                tools.append(
                    {
                        "name": getattr(block, "name", "unknown"),
                        "input": getattr(block, "input", {}),
                    }
                )
            elif hasattr(block, "name") and hasattr(block, "input"):
                # Fallback check
                tools.append(
                    {
                        "name": block.name,
                        "input": block.input,
                    }
                )
        return tools

    def _get_mcp_servers(self) -> dict[str, dict]:
        """Load enabled MCP server configs, filtered by tool policy.

        Returns a dict keyed by server name.  The SDK supports three
        transport types: stdio, sse, and http â€” each with its own
        TypedDict shape (McpStdioServerConfig, McpSSEServerConfig,
        McpHttpServerConfig).
        """
        try:
            from pocketpaw.mcp.config import load_mcp_config
        except ImportError:
            return {}

        configs = load_mcp_config()
        servers: dict[str, dict] = {}
        for cfg in configs:
            if not cfg.enabled:
                continue
            if not self._policy.is_mcp_server_allowed(cfg.name):
                logger.info("MCP server '%s' blocked by tool policy", cfg.name)
                continue

            if cfg.transport == "stdio":
                entry: dict = {"type": "stdio", "command": cfg.command}
                if cfg.args:
                    entry["args"] = cfg.args
                if cfg.env:
                    entry["env"] = cfg.env
            elif cfg.transport in ("http", "sse", "streamable-http"):
                if not cfg.url:
                    logger.warning("MCP server '%s' (%s) has no url", cfg.name, cfg.transport)
                    continue
                # Claude SDK expects "http" for both SSE and streamable-http
                sdk_type = "http" if cfg.transport == "streamable-http" else cfg.transport
                entry = {"type": sdk_type, "url": cfg.url}
                if cfg.env:
                    entry["headers"] = cfg.env
            else:
                logger.debug("Skipping MCP '%s' (unknown transport=%s)", cfg.name, cfg.transport)
                continue

            servers[cfg.name] = entry
        return servers

    @staticmethod
    def _merge_consecutive_roles(messages: list[dict]) -> list[dict]:
        """Merge consecutive messages with the same role for API compliance.

        The Anthropic API requires alternating user/assistant roles.
        Consecutive same-role messages are concatenated with newlines.
        """
        if not messages:
            return []
        merged: list[dict] = [messages[0].copy()]
        for msg in messages[1:]:
            if msg["role"] == merged[-1]["role"]:
                merged[-1]["content"] += "\n" + msg["content"]
            else:
                merged.append(msg.copy())
        return merged

    async def _fast_chat(
        self,
        message: str,
        *,
        system_prompt: str,
        history: list[dict] | None = None,
        model: str,
    ) -> AsyncIterator[AgentEvent]:
        """Direct Anthropic API path for simple messages.

        Bypasses the Claude CLI subprocess entirely, saving ~1.5-3s of
        process fork + Node.js startup + CLI initialization overhead.
        No tools are provided (simple messages don't need them).
        """
        try:
            import time

            from pocketpaw.llm.client import resolve_llm_client

            t0 = time.monotonic()
            llm = resolve_llm_client(self.settings)
            client = llm.create_anthropic_client()
            t1 = time.monotonic()
            logger.info("Fast-path: client created in %.0fms", (t1 - t0) * 1000)

            # Build API messages from history + current message
            api_messages: list[dict] = []
            if history:
                for msg in history:
                    role = msg.get("role", "user")
                    content = msg.get("content", "")
                    if role in ("user", "assistant") and content:
                        api_messages.append({"role": role, "content": content})
            api_messages.append({"role": "user", "content": message})

            # Merge consecutive same-role messages for API compliance
            api_messages = self._merge_consecutive_roles(api_messages)

            logger.info(
                "Fast-path: calling %s (system=%d chars, msgs=%d)",
                model,
                len(system_prompt),
                len(api_messages),
            )
            t2 = time.monotonic()

            async with client.messages.stream(
                model=model,
                system=system_prompt,
                messages=api_messages,
                max_tokens=1024,
            ) as stream:
                t3 = time.monotonic()
                logger.info("Fast-path: stream opened in %.0fms", (t3 - t2) * 1000)
                first_token = True
                async for text in stream.text_stream:
                    if first_token:
                        t4 = time.monotonic()
                        logger.info(
                            "Fast-path: first token in %.0fms (total %.0fms)",
                            (t4 - t3) * 1000,
                            (t4 - t0) * 1000,
                        )
                        first_token = False
                    if self._stop_flag:
                        logger.info("Fast-path: stop flag set, breaking stream")
                        break
                    yield AgentEvent(type="message", content=text)

            yield AgentEvent(type="done", content="")

        except Exception as e:
            from pocketpaw.llm.client import resolve_llm_client

            llm = resolve_llm_client(self.settings)
            logger.error("Fast-path API error: %s", e)
            yield AgentEvent(type="error", content=llm.format_api_error(e))

    async def _get_or_create_client(self, options: Any) -> Any:
        """Get or create a persistent ClaudeSDKClient.

        Reuses the existing subprocess if model and tools haven't changed.
        Reconnects when configuration changes are detected.
        """
        import time

        key = (
            f"{getattr(options, 'model', '')}:{sorted(getattr(options, 'allowed_tools', []) or [])}"
        )

        if self._client is not None and self._client_options_key == key:
            logger.debug("Reusing persistent client (key=%s)", key)
            return self._client

        # Disconnect stale client
        if self._client is not None:
            try:
                await self._client.disconnect()
            except Exception:
                pass
            self._client = None

        # Create and connect new client
        t0 = time.monotonic()
        self._client = self._ClaudeSDKClient(options=options)
        await self._client.connect()
        self._client_options_key = key
        t1 = time.monotonic()
        logger.info("Persistent client connected in %.0fms (key=%s)", (t1 - t0) * 1000, key)
        return self._client

    async def cleanup(self) -> None:
        """Disconnect the persistent client and release resources."""
        if self._client is not None:
            try:
                await self._client.disconnect()
            except Exception:
                pass
            self._client = None
            self._client_options_key = None
            self._client_in_use = False
            logger.info("Persistent client disconnected")

    async def run(
        self,
        message: str,
        *,
        system_prompt: str | None = None,
        history: list[dict] | None = None,
        session_key: str | None = None,
    ) -> AsyncIterator[AgentEvent]:
        """Process a message through Claude Agent SDK with streaming.

        Yields AgentEvent objects as the agent responds.
        """
        if not self._sdk_available:
            yield AgentEvent(
                type="error",
                content=(
                    "âŒ Claude Agent SDK Python package not found.\n\n"
                    "Install with: pip install claude-agent-sdk\n\n"
                    "Or switch to **PocketPaw Native** backend in **Settings â†’ General**."
                ),
            )
            return

        if not self._cli_available:
            yield AgentEvent(
                type="error",
                content=(
                    "âŒ Claude Code CLI not found on this machine.\n\n"
                    "Install with: `npm install -g @anthropic-ai/claude-code`\n\n"
                    "Or switch to **PocketPaw Native** backend in "
                    "**Settings â†’ General** â€” it uses the Anthropic API directly "
                    "and doesn't need the CLI."
                ),
            )
            return

        import os

        self._stop_flag = False

        try:
            # Resolve LLM provider early â€” needed for routing + env.
            # Use per-backend provider setting (defaults to "anthropic").
            # An API key is REQUIRED for Anthropic provider â€” OAuth tokens from
            # Claude Free/Pro/Max plans are not permitted for third-party use.
            # See: https://code.claude.com/docs/en/legal-and-compliance
            from pocketpaw.llm.client import resolve_llm_client

            provider = self.settings.claude_sdk_provider or "anthropic"
            llm = resolve_llm_client(self.settings, force_provider=provider)

            # â”€â”€ API key enforcement for Anthropic provider â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # Anthropic's policy prohibits using OAuth tokens from Free/Pro/Max
            # plans in third-party products. PocketPaw must use API key auth.
            if not (llm.is_ollama or llm.is_openai_compatible or llm.is_gemini):
                has_api_key = bool(
                    llm.api_key or os.environ.get("ANTHROPIC_API_KEY")
                )
                if not has_api_key:
                    yield AgentEvent(
                        type="error",
                        content=(
                            "**API key required** â€” The Claude SDK backend requires "
                            "an Anthropic API key.\n\n"
                            "Anthropic's policy prohibits third-party applications from "
                            "using OAuth tokens (Free/Pro/Max plan credentials). "
                            "PocketPaw must authenticate with an API key.\n\n"
                            "**How to fix:**\n"
                            "1. Get an API key at "
                            "[console.anthropic.com](https://console.anthropic.com/api-keys)\n"
                            "2. Add it in **Settings â†’ API Keys â†’ Anthropic API Key**\n"
                            "3. Or set the `ANTHROPIC_API_KEY` environment variable\n\n"
                            "*Alternatively, switch to **Ollama (Local)** in Settings "
                            "â†’ General for free local inference.*"
                        ),
                    )
                    return

            # Smart model routing â€” classify BEFORE prompt composition so we
            # can skip tool instructions for SIMPLE messages and dispatch to
            # the fast-path (direct API) for simple queries.
            is_simple = False
            selection = None
            if (
                self.settings.smart_routing_enabled
                and not llm.is_ollama
                and not llm.is_openai_compatible
                and not llm.is_gemini
            ):
                from pocketpaw.agents.model_router import ModelRouter, TaskComplexity

                model_router = ModelRouter(self.settings)
                selection = model_router.classify(message)
                is_simple = selection.complexity == TaskComplexity.SIMPLE
                logger.info(
                    "Smart routing: %s -> %s (%s)",
                    selection.complexity.value,
                    selection.model,
                    selection.reason,
                )

            # Fast path: bypass CLI subprocess entirely for simple messages.
            # Uses the Anthropic API directly (requires API key, already enforced above).
            has_api_key = bool(llm.api_key or os.environ.get("ANTHROPIC_API_KEY"))
            if is_simple and selection is not None and has_api_key:
                identity = system_prompt or _DEFAULT_IDENTITY
                async for event in self._fast_chat(
                    message,
                    system_prompt=identity,
                    history=history,
                    model=selection.model,
                ):
                    yield event
                return

            # System prompt â€” instructions are now part of identity
            # (injected by BootstrapContext.to_system_prompt() via INSTRUCTIONS.md)
            identity = system_prompt or _DEFAULT_IDENTITY
            final_prompt = identity

            # Inject session history into system prompt (SDK query() takes a single string)
            if history:
                lines = ["# Recent Conversation"]
                for msg in history:
                    role = msg.get("role", "user").capitalize()
                    content = msg.get("content", "")
                    # Truncate very long messages to keep prompt manageable
                    if len(content) > 500:
                        content = content[:500] + "..."
                    lines.append(f"**{role}**: {content}")
                final_prompt += "\n\n" + "\n".join(lines)

            # Build allowed tools list, filtered by tool policy
            all_sdk_tools = [
                "Bash",
                "Read",
                "Write",
                "Edit",
                "Glob",
                "Grep",
                "WebSearch",
                "WebFetch",
                "Skill",
            ]
            allowed_tools = [
                t
                for t in all_sdk_tools
                if self._policy.is_tool_allowed(self._TOOL_POLICY_MAP.get(t, t))
            ]
            if len(allowed_tools) < len(all_sdk_tools):
                blocked = set(all_sdk_tools) - set(allowed_tools)
                logger.info("Tool policy blocked SDK tools: %s", blocked)

            # Build hooks for security
            hooks = {
                "PreToolUse": [
                    self._HookMatcher(
                        matcher="Bash",  # Only hook Bash commands
                        hooks=[self._block_dangerous_hook],
                    )
                ]
            }

            # Build options
            options_kwargs = {
                "system_prompt": final_prompt,
                "allowed_tools": allowed_tools,
                "setting_sources": ["user", "project"],
                "hooks": hooks,
                "cwd": str(self._cwd),
                "max_turns": self.settings.claude_sdk_max_turns or None,
            }

            # Configure LLM provider for the Claude CLI subprocess.
            # API key is enforced above for Anthropic; Ollama/OpenAI-compat
            # providers set their own env vars via to_sdk_env().
            sdk_env = llm.to_sdk_env()
            if not sdk_env:
                env_key = os.environ.get("ANTHROPIC_API_KEY")
                if env_key:
                    sdk_env = {"ANTHROPIC_API_KEY": env_key}
            if sdk_env:
                options_kwargs["env"] = sdk_env
            if llm.is_ollama or llm.is_openai_compatible or llm.is_gemini:
                options_kwargs["model"] = llm.model

            # Wire in MCP servers (policy-filtered)
            mcp_servers = self._get_mcp_servers()
            if mcp_servers:
                options_kwargs["mcp_servers"] = mcp_servers
                logger.info("MCP: passing %d servers to Claude SDK", len(mcp_servers))

            # Enable token-by-token streaming if StreamEvent is available
            if self._StreamEvent is not None:
                options_kwargs["include_partial_messages"] = True

            # Permission handling â€” PocketPaw runs headless (web/chat), so
            # there is no terminal to show interactive permission prompts.
            # bypassPermissions auto-approves ALL tool calls (including MCP).
            # Dangerous Bash commands are still caught by the PreToolUse hook.
            if self.settings.bypass_permissions:
                options_kwargs["permission_mode"] = "bypassPermissions"

            # Model selection for Anthropic providers:
            # 1. Smart routing (opt-in) â€” overrides with complexity-based model
            # 2. Explicit claude_sdk_model â€” user-chosen fixed model
            # 3. Neither set â€” let Claude Code CLI auto-select (recommended)
            if not (llm.is_ollama or llm.is_openai_compatible or llm.is_gemini):
                if self.settings.smart_routing_enabled:
                    from pocketpaw.agents.model_router import ModelRouter

                    model_router = ModelRouter(self.settings)
                    selection = model_router.classify(message)
                    options_kwargs["model"] = selection.model
                elif self.settings.claude_sdk_model:
                    options_kwargs["model"] = self.settings.claude_sdk_model

            # Capture stderr for better error diagnostics
            _stderr_lines: list[str] = []

            def _on_stderr(line: str) -> None:
                _stderr_lines.append(line)
                logger.debug("Claude CLI stderr: %s", line)

            options_kwargs["stderr"] = _on_stderr

            # Create options (after all kwargs are set, including model)
            options = self._ClaudeAgentOptions(**options_kwargs)

            logger.debug(f"ðŸš€ Starting Claude Agent SDK query: {message[:100]}...")

            # Try persistent client first, fall back to stateless query.
            # _client_in_use guard prevents concurrent queries on the same
            # subprocess â€” cross-session messages fall back to stateless query.
            event_stream = None
            if not self._client_in_use:
                try:
                    self._client_in_use = True
                    client = await self._get_or_create_client(options)
                    await client.query(message)
                    event_stream = client.receive_response()
                except Exception as client_err:
                    logger.warning(
                        "Persistent client failed, falling back to stateless query: %s",
                        client_err,
                    )
                    # Clear broken client so next call creates a fresh one
                    self._client = None
                    self._client_options_key = None
                    self._client_in_use = False

            if event_stream is None:
                event_stream = self._query(prompt=message, options=options)

            # State tracking for StreamEvent deduplication
            _streamed_via_events = False
            _announced_tools: set[str] = set()

            # Stream responses â€” release the persistent client guard when done
            try:
                async for event in event_stream:
                    if self._stop_flag:
                        logger.info("ðŸ›‘ Stop flag set, breaking stream")
                        break

                    # Handle different message types using isinstance checks

                    # ========== StreamEvent - token-by-token streaming ==========
                    if self._StreamEvent and isinstance(event, self._StreamEvent):
                        raw = getattr(event, "event", None) or {}
                        event_type = raw.get("type", "")
                        delta = raw.get("delta", {})

                        if event_type == "content_block_delta":
                            if "text" in delta:
                                yield AgentEvent(type="message", content=delta["text"])
                                _streamed_via_events = True
                            elif "thinking" in delta:
                                yield AgentEvent(type="thinking", content=delta["thinking"])
                        elif event_type == "content_block_start":
                            cb = raw.get("content_block", {})
                            if cb.get("type") == "tool_use":
                                tool_name = cb.get("name", "unknown")
                                _announced_tools.add(tool_name)
                                yield AgentEvent(
                                    type="tool_use",
                                    content=f"Using {tool_name}...",
                                    metadata={"name": tool_name, "input": {}},
                                )
                        elif event_type == "content_block_stop":
                            if getattr(event, "_block_type", None) == "thinking":
                                yield AgentEvent(type="thinking_done", content="")
                        continue

                    # ========== SystemMessage - metadata, skip ==========
                    if self._SystemMessage and isinstance(event, self._SystemMessage):
                        subtype = getattr(event, "subtype", "")
                        logger.debug(f"SystemMessage: {subtype}")
                        continue

                    # ========== UserMessage - extract media from tool results ==========
                    if self._UserMessage and isinstance(event, self._UserMessage):
                        # UserMessages in multi-turn SDK flow contain ToolResultBlocks
                        # with the raw output of Bash commands (including media tags).
                        if hasattr(event, "content") and isinstance(event.content, list):
                            for block in event.content:
                                if not (
                                    self._ToolResultBlock
                                    and isinstance(block, self._ToolResultBlock)
                                ):
                                    continue
                                block_content = getattr(block, "content", "")
                                if isinstance(block_content, str):
                                    result_text = block_content
                                elif isinstance(block_content, list):
                                    result_text = " ".join(
                                        getattr(b, "text", "")
                                        for b in block_content
                                        if hasattr(b, "text")
                                    )
                                else:
                                    continue
                                if result_text and "<!-- media:" in result_text:
                                    yield AgentEvent(
                                        type="tool_result",
                                        content=result_text,
                                        metadata={"name": "bash"},
                                    )
                        logger.debug("UserMessage processed")
                        continue

                    # ========== AssistantMessage - main content ==========
                    if self._AssistantMessage and isinstance(event, self._AssistantMessage):
                        if not _streamed_via_events:
                            text = self._extract_text_from_message(event)
                            if text:
                                yield AgentEvent(type="message", content=text)

                        tools = self._extract_tool_info(event)
                        for tool in tools:
                            if tool["name"] not in _announced_tools:
                                logger.info(f"ðŸ”§ Tool: {tool['name']}")
                                yield AgentEvent(
                                    type="tool_use",
                                    content=f"Using {tool['name']}...",
                                    metadata={
                                        "name": tool["name"],
                                        "input": tool["input"],
                                    },
                                )

                        _streamed_via_events = False
                        _announced_tools.clear()
                        continue

                    # ========== ResultMessage - final result ==========
                    if self._ResultMessage and isinstance(event, self._ResultMessage):
                        is_error = getattr(event, "is_error", False)
                        result = getattr(event, "result", "")

                        if is_error:
                            logger.error(f"ResultMessage error: {result}")
                            yield AgentEvent(type="error", content=str(result))
                        else:
                            logger.debug(f"ResultMessage: {str(result)[:100]}...")
                        continue

                    # ========== Unknown event type - log it ==========
                    event_class = event.__class__.__name__
                    logger.debug(f"Unknown event type: {event_class}")
            finally:
                self._client_in_use = False

            yield AgentEvent(type="done", content="")

        except Exception as e:
            error_msg = str(e)
            logger.error(f"Claude Agent SDK error: {error_msg}")

            # Clear client on unexpected errors
            self._client = None
            self._client_options_key = None
            self._client_in_use = False

            # Provide helpful error messages
            if "CLINotFoundError" in error_msg:
                yield AgentEvent(
                    type="error",
                    content=(
                        "âŒ Claude Code CLI not found.\n\n"
                        "Install with: npm install -g @anthropic-ai/claude-code\n\n"
                        "Or switch to a different backend in "
                        "**Settings â†’ General**."
                    ),
                )
            else:
                stderr_text = "\n".join(_stderr_lines) if _stderr_lines else ""
                yield AgentEvent(
                    type="error",
                    content=llm.format_api_error(e, stderr=stderr_text),
                )

    async def stop(self) -> None:
        """Stop the agent execution and disconnect persistent client."""
        self._stop_flag = True
        if self._client is not None:
            try:
                await self._client.interrupt()
            except Exception:
                pass
        await self.cleanup()
        logger.info("ðŸ›‘ Claude Agent SDK stop requested")

    async def get_status(self) -> dict:
        """Get current agent status."""
        ready = self._sdk_available and self._cli_available
        return {
            "backend": "claude_agent_sdk",
            "available": ready,
            "sdk_installed": self._sdk_available,
            "cli_installed": self._cli_available,
            "running": not self._stop_flag,
            "cwd": str(self._cwd),
            "features": ["Bash", "Read", "Write", "Edit", "Glob", "Grep", "WebSearch", "WebFetch"]
            if ready
            else [],
        }


# Backward-compat aliases
ClaudeAgentSDK = ClaudeSDKBackend
ClaudeAgentSDKWrapper = ClaudeSDKBackend
